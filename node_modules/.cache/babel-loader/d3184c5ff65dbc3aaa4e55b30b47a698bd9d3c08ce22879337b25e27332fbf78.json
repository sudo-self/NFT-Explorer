{"ast":null,"code":"/**\n *  Generally the [[Wallet]] and [[JsonRpcSigner]] and their sub-classes\n *  are sufficent for most developers, but this is provided to\n *  fascilitate more complex Signers.\n *\n *  @_section: api/providers/abstract-signer: Subclassing Signer [abstract-signer]\n */\nimport { resolveAddress } from \"../address/index.js\";\nimport { Transaction } from \"../transaction/index.js\";\nimport { defineProperties, getBigInt, resolveProperties, assert, assertArgument } from \"../utils/index.js\";\nimport { copyRequest } from \"./provider.js\";\nfunction checkProvider(signer, operation) {\n  if (signer.provider) {\n    return signer.provider;\n  }\n  assert(false, \"missing provider\", \"UNSUPPORTED_OPERATION\", {\n    operation\n  });\n}\nasync function populate(signer, tx) {\n  let pop = copyRequest(tx);\n  if (pop.to != null) {\n    pop.to = resolveAddress(pop.to, signer);\n  }\n  if (pop.from != null) {\n    const from = pop.from;\n    pop.from = Promise.all([signer.getAddress(), resolveAddress(from, signer)]).then(_ref => {\n      let [address, from] = _ref;\n      assertArgument(address.toLowerCase() === from.toLowerCase(), \"transaction from mismatch\", \"tx.from\", from);\n      return address;\n    });\n  } else {\n    pop.from = signer.getAddress();\n  }\n  return await resolveProperties(pop);\n}\n/**\n *  An **AbstractSigner** includes most of teh functionality required\n *  to get a [[Signer]] working as expected, but requires a few\n *  Signer-specific methods be overridden.\n *\n */\nexport class AbstractSigner {\n  /**\n   *  The provider this signer is connected to.\n   */\n  provider;\n  /**\n   *  Creates a new Signer connected to %%provider%%.\n   */\n  constructor(provider) {\n    defineProperties(this, {\n      provider: provider || null\n    });\n  }\n  async getNonce(blockTag) {\n    return checkProvider(this, \"getTransactionCount\").getTransactionCount(await this.getAddress(), blockTag);\n  }\n  async populateCall(tx) {\n    const pop = await populate(this, tx);\n    return pop;\n  }\n  async populateTransaction(tx) {\n    const provider = checkProvider(this, \"populateTransaction\");\n    const pop = await populate(this, tx);\n    if (pop.nonce == null) {\n      pop.nonce = await this.getNonce(\"pending\");\n    }\n    if (pop.gasLimit == null) {\n      pop.gasLimit = await this.estimateGas(pop);\n    }\n    // Populate the chain ID\n    const network = await this.provider.getNetwork();\n    if (pop.chainId != null) {\n      const chainId = getBigInt(pop.chainId);\n      assertArgument(chainId === network.chainId, \"transaction chainId mismatch\", \"tx.chainId\", tx.chainId);\n    } else {\n      pop.chainId = network.chainId;\n    }\n    // Do not allow mixing pre-eip-1559 and eip-1559 properties\n    const hasEip1559 = pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null;\n    if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {\n      assertArgument(false, \"eip-1559 transaction do not support gasPrice\", \"tx\", tx);\n    } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {\n      assertArgument(false, \"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"tx\", tx);\n    }\n    if ((pop.type === 2 || pop.type == null) && pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null) {\n      // Fully-formed EIP-1559 transaction (skip getFeeData)\n      pop.type = 2;\n    } else if (pop.type === 0 || pop.type === 1) {\n      // Explicit Legacy or EIP-2930 transaction\n      // We need to get fee data to determine things\n      const feeData = await provider.getFeeData();\n      assert(feeData.gasPrice != null, \"network does not support gasPrice\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"getGasPrice\"\n      });\n      // Populate missing gasPrice\n      if (pop.gasPrice == null) {\n        pop.gasPrice = feeData.gasPrice;\n      }\n    } else {\n      // We need to get fee data to determine things\n      const feeData = await provider.getFeeData();\n      if (pop.type == null) {\n        // We need to auto-detect the intended type of this transaction...\n        if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n          // The network supports EIP-1559!\n          // Upgrade transaction from null to eip-1559\n          if (pop.authorizationList && pop.authorizationList.length) {\n            pop.type = 4;\n          } else {\n            pop.type = 2;\n          }\n          if (pop.gasPrice != null) {\n            // Using legacy gasPrice property on an eip-1559 network,\n            // so use gasPrice as both fee properties\n            const gasPrice = pop.gasPrice;\n            delete pop.gasPrice;\n            pop.maxFeePerGas = gasPrice;\n            pop.maxPriorityFeePerGas = gasPrice;\n          } else {\n            // Populate missing fee data\n            if (pop.maxFeePerGas == null) {\n              pop.maxFeePerGas = feeData.maxFeePerGas;\n            }\n            if (pop.maxPriorityFeePerGas == null) {\n              pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n            }\n          }\n        } else if (feeData.gasPrice != null) {\n          // Network doesn't support EIP-1559...\n          // ...but they are trying to use EIP-1559 properties\n          assert(!hasEip1559, \"network does not support EIP-1559\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"populateTransaction\"\n          });\n          // Populate missing fee data\n          if (pop.gasPrice == null) {\n            pop.gasPrice = feeData.gasPrice;\n          }\n          // Explicitly set untyped transaction to legacy\n          // @TODO: Maybe this shold allow type 1?\n          pop.type = 0;\n        } else {\n          // getFeeData has failed us.\n          assert(false, \"failed to get consistent fee data\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"signer.getFeeData\"\n          });\n        }\n      } else if (pop.type === 2 || pop.type === 3 || pop.type === 4) {\n        // Explicitly using EIP-1559 or EIP-4844\n        // Populate missing fee data\n        if (pop.maxFeePerGas == null) {\n          pop.maxFeePerGas = feeData.maxFeePerGas;\n        }\n        if (pop.maxPriorityFeePerGas == null) {\n          pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n        }\n      }\n    }\n    //@TOOD: Don't await all over the place; save them up for\n    // the end for better batching\n    return await resolveProperties(pop);\n  }\n  async populateAuthorization(_auth) {\n    const auth = Object.assign({}, _auth);\n    // Add a chain ID if not explicitly set to 0\n    if (auth.chainId == null) {\n      auth.chainId = (await checkProvider(this, \"getNetwork\").getNetwork()).chainId;\n    }\n    // @TODO: Take chain ID into account when populating noce?\n    if (auth.nonce == null) {\n      auth.nonce = await this.getNonce();\n    }\n    return auth;\n  }\n  async estimateGas(tx) {\n    return checkProvider(this, \"estimateGas\").estimateGas(await this.populateCall(tx));\n  }\n  async call(tx) {\n    return checkProvider(this, \"call\").call(await this.populateCall(tx));\n  }\n  async resolveName(name) {\n    const provider = checkProvider(this, \"resolveName\");\n    return await provider.resolveName(name);\n  }\n  async sendTransaction(tx) {\n    const provider = checkProvider(this, \"sendTransaction\");\n    const pop = await this.populateTransaction(tx);\n    delete pop.from;\n    const txObj = Transaction.from(pop);\n    return await provider.broadcastTransaction(await this.signTransaction(txObj));\n  }\n  // @TODO: in v7 move this to be abstract\n  authorize(authorization) {\n    assert(false, \"authorization not implemented for this signer\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"authorize\"\n    });\n  }\n}\n/**\n *  A **VoidSigner** is a class deisgned to allow an address to be used\n *  in any API which accepts a Signer, but for which there are no\n *  credentials available to perform any actual signing.\n *\n *  This for example allow impersonating an account for the purpose of\n *  static calls or estimating gas, but does not allow sending transactions.\n */\nexport class VoidSigner extends AbstractSigner {\n  /**\n   *  The signer address.\n   */\n  address;\n  /**\n   *  Creates a new **VoidSigner** with %%address%% attached to\n   *  %%provider%%.\n   */\n  constructor(address, provider) {\n    super(provider);\n    defineProperties(this, {\n      address\n    });\n  }\n  async getAddress() {\n    return this.address;\n  }\n  connect(provider) {\n    return new VoidSigner(this.address, provider);\n  }\n  #throwUnsupported(suffix, operation) {\n    assert(false, `VoidSigner cannot sign ${suffix}`, \"UNSUPPORTED_OPERATION\", {\n      operation\n    });\n  }\n  async signTransaction(tx) {\n    this.#throwUnsupported(\"transactions\", \"signTransaction\");\n  }\n  async signMessage(message) {\n    this.#throwUnsupported(\"messages\", \"signMessage\");\n  }\n  async signTypedData(domain, types, value) {\n    this.#throwUnsupported(\"typed-data\", \"signTypedData\");\n  }\n}","map":{"version":3,"names":["resolveAddress","Transaction","defineProperties","getBigInt","resolveProperties","assert","assertArgument","copyRequest","checkProvider","signer","operation","provider","populate","tx","pop","to","from","Promise","all","getAddress","then","_ref","address","toLowerCase","AbstractSigner","constructor","getNonce","blockTag","getTransactionCount","populateCall","populateTransaction","nonce","gasLimit","estimateGas","network","getNetwork","chainId","hasEip1559","maxFeePerGas","maxPriorityFeePerGas","gasPrice","type","feeData","getFeeData","authorizationList","length","populateAuthorization","_auth","auth","Object","assign","call","resolveName","name","sendTransaction","txObj","broadcastTransaction","signTransaction","authorize","authorization","VoidSigner","connect","throwUnsupported","#throwUnsupported","suffix","signMessage","message","signTypedData","domain","types","value"],"sources":["/opt/homebrew/var/www/wolf/untitled folder 2/Build-Your-NFT-Explorer/untitled folder/NFT-Explorer/node_modules/.pnpm/ethers@6.15.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ethers/src.ts/providers/abstract-signer.ts"],"sourcesContent":["/**\n *  Generally the [[Wallet]] and [[JsonRpcSigner]] and their sub-classes\n *  are sufficent for most developers, but this is provided to\n *  fascilitate more complex Signers.\n *\n *  @_section: api/providers/abstract-signer: Subclassing Signer [abstract-signer]\n */\nimport { resolveAddress } from \"../address/index.js\";\nimport { Transaction } from \"../transaction/index.js\";\nimport {\n    defineProperties, getBigInt, resolveProperties,\n    assert, assertArgument\n} from \"../utils/index.js\";\n\nimport { copyRequest } from \"./provider.js\";\n\nimport type {\n    AuthorizationRequest, TypedDataDomain, TypedDataField\n} from \"../hash/index.js\";\nimport type { Authorization, TransactionLike } from \"../transaction/index.js\";\n\nimport type {\n    BlockTag, Provider, TransactionRequest, TransactionResponse\n} from \"./provider.js\";\nimport type { Signer } from \"./signer.js\";\n\nfunction checkProvider(signer: AbstractSigner, operation: string): Provider {\n    if (signer.provider) { return signer.provider; }\n    assert(false, \"missing provider\", \"UNSUPPORTED_OPERATION\", { operation });\n}\n\nasync function populate(signer: AbstractSigner, tx: TransactionRequest): Promise<TransactionLike<string>> {\n    let pop: any = copyRequest(tx);\n\n    if (pop.to != null) { pop.to = resolveAddress(pop.to, signer); }\n\n    if (pop.from != null) {\n        const from = pop.from;\n        pop.from = Promise.all([\n            signer.getAddress(),\n            resolveAddress(from, signer)\n        ]).then(([ address, from ]) => {\n            assertArgument(address.toLowerCase() === from.toLowerCase(),\n                \"transaction from mismatch\", \"tx.from\", from);\n            return address;\n        });\n    } else {\n        pop.from = signer.getAddress();\n    }\n\n    return await resolveProperties(pop);\n}\n\n\n/**\n *  An **AbstractSigner** includes most of teh functionality required\n *  to get a [[Signer]] working as expected, but requires a few\n *  Signer-specific methods be overridden.\n *\n */\nexport abstract class AbstractSigner<P extends null | Provider = null | Provider> implements Signer {\n    /**\n     *  The provider this signer is connected to.\n     */\n    readonly provider!: P;\n\n    /**\n     *  Creates a new Signer connected to %%provider%%.\n     */\n    constructor(provider?: P) {\n        defineProperties<AbstractSigner>(this, { provider: (provider || null) });\n    }\n\n    /**\n     *  Resolves to the Signer address.\n     */\n    abstract getAddress(): Promise<string>;\n\n    /**\n     *  Returns the signer connected to %%provider%%.\n     *\n     *  This may throw, for example, a Signer connected over a Socket or\n     *  to a specific instance of a node may not be transferrable.\n     */\n    abstract connect(provider: null | Provider): Signer;\n\n    async getNonce(blockTag?: BlockTag): Promise<number> {\n        return checkProvider(this, \"getTransactionCount\").getTransactionCount(await this.getAddress(), blockTag);\n    }\n\n    async populateCall(tx: TransactionRequest): Promise<TransactionLike<string>> {\n        const pop = await populate(this, tx);\n        return pop;\n    }\n\n    async populateTransaction(tx: TransactionRequest): Promise<TransactionLike<string>> {\n        const provider = checkProvider(this, \"populateTransaction\");\n\n        const pop = await populate(this, tx);\n\n        if (pop.nonce == null) {\n            pop.nonce = await this.getNonce(\"pending\");\n        }\n\n        if (pop.gasLimit == null) {\n            pop.gasLimit = await this.estimateGas(pop);\n        }\n\n        // Populate the chain ID\n        const network = await (<Provider>(this.provider)).getNetwork();\n        if (pop.chainId != null) {\n            const chainId = getBigInt(pop.chainId);\n            assertArgument(chainId === network.chainId, \"transaction chainId mismatch\", \"tx.chainId\", tx.chainId);\n        } else {\n            pop.chainId = network.chainId;\n        }\n\n        // Do not allow mixing pre-eip-1559 and eip-1559 properties\n        const hasEip1559 = (pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null);\n        if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {\n            assertArgument(false, \"eip-1559 transaction do not support gasPrice\", \"tx\", tx);\n        } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {\n            assertArgument(false, \"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"tx\", tx);\n        }\n\n        if ((pop.type === 2 || pop.type == null) && (pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null)) {\n            // Fully-formed EIP-1559 transaction (skip getFeeData)\n            pop.type = 2;\n\n        } else if (pop.type === 0 || pop.type === 1) {\n            // Explicit Legacy or EIP-2930 transaction\n\n            // We need to get fee data to determine things\n            const feeData = await provider.getFeeData();\n\n            assert(feeData.gasPrice != null, \"network does not support gasPrice\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"getGasPrice\" });\n\n            // Populate missing gasPrice\n            if (pop.gasPrice == null) { pop.gasPrice = feeData.gasPrice; }\n\n        } else {\n\n            // We need to get fee data to determine things\n            const feeData = await provider.getFeeData();\n\n            if (pop.type == null) {\n                // We need to auto-detect the intended type of this transaction...\n\n                if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n                    // The network supports EIP-1559!\n\n                    // Upgrade transaction from null to eip-1559\n                    if (pop.authorizationList && pop.authorizationList.length) {\n                        pop.type = 4;\n                    } else {\n                        pop.type = 2;\n                    }\n\n                    if (pop.gasPrice != null) {\n                        // Using legacy gasPrice property on an eip-1559 network,\n                        // so use gasPrice as both fee properties\n                        const gasPrice = pop.gasPrice;\n                        delete pop.gasPrice;\n                        pop.maxFeePerGas = gasPrice;\n                        pop.maxPriorityFeePerGas = gasPrice;\n\n                    } else {\n                        // Populate missing fee data\n\n                        if (pop.maxFeePerGas == null) {\n                            pop.maxFeePerGas = feeData.maxFeePerGas;\n                        }\n\n                        if (pop.maxPriorityFeePerGas == null) {\n                            pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                        }\n                    }\n\n                } else if (feeData.gasPrice != null) {\n                    // Network doesn't support EIP-1559...\n\n                    // ...but they are trying to use EIP-1559 properties\n                    assert(!hasEip1559, \"network does not support EIP-1559\", \"UNSUPPORTED_OPERATION\", {\n                            operation: \"populateTransaction\" });\n\n                    // Populate missing fee data\n                    if (pop.gasPrice == null) {\n                        pop.gasPrice = feeData.gasPrice;\n                    }\n\n                    // Explicitly set untyped transaction to legacy\n                    // @TODO: Maybe this shold allow type 1?\n                    pop.type = 0;\n\n               } else {\n                    // getFeeData has failed us.\n                    assert(false, \"failed to get consistent fee data\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"signer.getFeeData\" });\n                }\n\n            } else if (pop.type === 2 || pop.type === 3 || pop.type === 4) {\n                // Explicitly using EIP-1559 or EIP-4844\n\n                // Populate missing fee data\n                if (pop.maxFeePerGas == null) {\n                    pop.maxFeePerGas = feeData.maxFeePerGas;\n                }\n\n                if (pop.maxPriorityFeePerGas == null) {\n                    pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                }\n            }\n        }\n\n//@TOOD: Don't await all over the place; save them up for\n// the end for better batching\n        return await resolveProperties(pop);\n    }\n\n    async populateAuthorization(_auth: AuthorizationRequest): Promise<AuthorizationRequest> {\n        const auth = Object.assign({ }, _auth);\n\n        // Add a chain ID if not explicitly set to 0\n        if (auth.chainId == null) {\n            auth.chainId = (await checkProvider(this, \"getNetwork\").getNetwork()).chainId;\n        }\n\n        // @TODO: Take chain ID into account when populating noce?\n\n        if (auth.nonce == null) { auth.nonce = await this.getNonce(); }\n\n        return auth;\n    }\n\n    async estimateGas(tx: TransactionRequest): Promise<bigint> {\n        return checkProvider(this, \"estimateGas\").estimateGas(await this.populateCall(tx));\n    }\n\n    async call(tx: TransactionRequest): Promise<string> {\n        return checkProvider(this, \"call\").call(await this.populateCall(tx));\n    }\n\n    async resolveName(name: string): Promise<null | string> {\n        const provider = checkProvider(this, \"resolveName\");\n        return await provider.resolveName(name);\n    }\n\n    async sendTransaction(tx: TransactionRequest): Promise<TransactionResponse> {\n        const provider = checkProvider(this, \"sendTransaction\");\n\n        const pop = await this.populateTransaction(tx);\n        delete pop.from;\n        const txObj = Transaction.from(pop);\n        return await provider.broadcastTransaction(await this.signTransaction(txObj));\n    }\n\n    // @TODO: in v7 move this to be abstract\n    authorize(authorization: AuthorizationRequest): Promise<Authorization> {\n        assert(false, \"authorization not implemented for this signer\",\n          \"UNSUPPORTED_OPERATION\", { operation: \"authorize\" });\n    }\n\n    abstract signTransaction(tx: TransactionRequest): Promise<string>;\n    abstract signMessage(message: string | Uint8Array): Promise<string>;\n    abstract signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string>;\n}\n\n/**\n *  A **VoidSigner** is a class deisgned to allow an address to be used\n *  in any API which accepts a Signer, but for which there are no\n *  credentials available to perform any actual signing.\n *\n *  This for example allow impersonating an account for the purpose of\n *  static calls or estimating gas, but does not allow sending transactions.\n */\nexport class VoidSigner extends AbstractSigner {\n    /**\n     *  The signer address.\n     */\n    readonly address!: string;\n\n    /**\n     *  Creates a new **VoidSigner** with %%address%% attached to\n     *  %%provider%%.\n     */\n    constructor(address: string, provider?: null | Provider) {\n        super(provider);\n        defineProperties<VoidSigner>(this, { address });\n    }\n\n    async getAddress(): Promise<string> { return this.address; }\n\n    connect(provider: null | Provider): VoidSigner {\n        return new VoidSigner(this.address, provider);\n    }\n\n    #throwUnsupported(suffix: string, operation: string): never {\n        assert(false, `VoidSigner cannot sign ${ suffix }`, \"UNSUPPORTED_OPERATION\", { operation });\n    }\n\n    async signTransaction(tx: TransactionRequest): Promise<string> {\n        this.#throwUnsupported(\"transactions\", \"signTransaction\");\n    }\n\n    async signMessage(message: string | Uint8Array): Promise<string> {\n        this.#throwUnsupported(\"messages\", \"signMessage\");\n    }\n\n    async signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n        this.#throwUnsupported(\"typed-data\", \"signTypedData\");\n    }\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}